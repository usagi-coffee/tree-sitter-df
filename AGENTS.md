# AGENTS.md

## Project

- Tree-sitter grammar for OpenEdge DF.

## Key paths

- `grammar.js`: core grammar rules.
- `src/scanner.c`: external scanner implementation.
- `src/parser.c`, `src/grammar.json`, `src/node-types.json`: generated by `tree-sitter generate`.
- `test/corpus/`: tree-sitter corpus tests.
- `bindings/`: language bindings.

## Workflow

- Run tests:
  - `bun run test`
- Run a specific test:
  - `bun run test --include 'TEST NAME'`
  - Example: `bun run test --include 'WORKFILE DEFINITION - Shared/Private variants'` Parse a file:
  - `bun run parse <file>`
  - Example: `bun run parse example.df`
- Parse a snippet:
  - `bun run parse:snippet <direct syntax string>`
  - Example: `bun run parse:snippet 'a = b + c.'`
- Build native and wasm artifacts:
  - `bun run build` -> df.so
  - `bun run build:wasm` -> tree-sitter-df.wasm

## Conventions

- Always run tests after modifications.
- Do not remove tests unless it is illegal syntax.
- Grammar changes without thorough corpus coverage and testing are unacceptable.
- Always prefere adding to `precedences` over using `prec(`.
- Prefer `kw` for keywords in place of `token(/keyword/i)`, when the syntax supports partial keyword like `DEFINE` can be `DEF`, `DEFI`, `DEFIN` and `DEFINE` please use `kw("DEFINE", { offset: 3 })`, for scenario where it can be longer do alias e.g`kw("FIELDS", { alias: 'FIELD', offset: 5)`.
- Treat `(ERROR)` and `(MISSING)` nodes in the test output aserrors that need to be fixed.
- Use compact rule formatting: keep one-line rules adjacent with no blank lines, avoid blank lines between consecutive one-line rules.
- The grammar should avoid permissive or catch-all rules that allow invalid syntax to be parsed successfully.
- Do not adjust or remove tests just to satisfy test passing, just fix the underlying parsing issue or ask me first to remove if it's really not supported.
- Don't write unnecessary comments.
- Never add `(ERROR` nodes to expected syntax trees in tests, it's pointless, fix the grammar not the test itself.
- Prefer not using `_list` suffix for rules e.g `_format_label_list` should be `_format_labels`.
- Add purpose + example comments before each precedence group when modifying precedences; add reference notes for each precedence entry.
- *Only* if needed, refactor rules to be easier to target in precedence (e.g you can't target repeat(some_rule), its fine to refactor into e.g `__statement_expression: ($) => $._expression`.
- Any newly added grammar warrants adding a tests for it, please write tests for new grammar constructs.
- For options of statement with values prefer e.g `seq(kw("ROW"), field("row", ...))` for those that can have expressions and e.g `alias(kw("NO-LABELS", $.no_labels))` for those that do not have expressions.
- Do not use e.g `no_labels_option` as an alias, just use `no_labels` to keep it clean, avoid `_option` suffix.

## Clean tree conventions

We want the syntax tree output to be flattened unless necessary, prefer `field` for non-repeating rules and `alias` for flags.

1. Add fields for modifiers that take value.
```js
// Bad
seq(kw("DELIMITER"), $.string_literal),

// Good
seq(kw("DELIMITER"), field("delimiter", $.string_literal))
```

2. Alias trivial flags and avoid `_option` suffix.

Trivial flags are:
 - "NO-ERROR", "NO-LOBS", etc
 - any `optional(kw("..."))`

Trivial flags are NOT:
 - starting statement keywords
 - keywords before terminatotor e.g `optional(kw("CASE"))`.
 - `choice(kw("1"), kw("2"), ...)`, those should be moved into a separate rule/phrase

```js
// Bad
alias($.__no_labels, $.no_labels_option)

// Good
alias(kw("NO-LABELS"), $.no_labels),
```

3. Remove trivial* helpers

Trivial rules are:
 - rules like `__statement_no_error: ($) => kw("NO-ERROR")`
 - rules like `__statement_format: ($) => seq(kw("FORMAT"), $.string_literal)`

Trivial rules are NOT rules that:
 - are choice rules like `__error_scope_type: ($) => choice(kw("BLOCK-LEVEL"), kw("ROUTINE-LEVEL")),` are non-trivial, do not remove them!
 - are main `_body` rules of the statement e.g `__input_clear_body`, those need to stay as they get optimized better.

```js
// Bad
__option: ($) => choice(
    alias($.__option_no_labels, $.no_labels_option)
  ),
__option_no_labels ($) => alias(kw("NO-LABELS", $.no_labels))

// Good 
__option: ($) => choice(
    alias(kw("NO-LABELS"), $.no_labels),
  ),
```


4. Redundant double-alias nesting
```js
// Bad
optional(alias($.__x_no_undo, $.no_undo)),
__x_no_undo: ($) => alias(kw("NO-UNDO"), $.no_undo),

// Good
optional(alias(kw("NO-UNDO"), $.no_undo)),
```

5. Keep lexical-token aliasing at callsite (do not move alias into helper)
```js
// Bad
__rule: ($) seq($.__input_through_shell_variable),
__input_through_shell_variable: ($) => alias(token(/\$+[A-Za-z_0-9]*/), $.shell_variable),
// Also Bad
__input_through_shell_variable: ($) => alias(token(/\$+[A-Za-z_0-9]*/), $.shell_variable)


// Good
alias($.__input_through_shell_variable, $.shell_variable),
__input_through_shell_variable: ($) => token(/\$+[A-Za-z_0-9]*/),
```

6. Phrases-like rules should be kept in a separate rule and aliased
```js
// Bad
optional($.__find_of_phrase),
__find_of_phrase: ($) => seq(kw("OF"), $.__find_record_name),

// Good
optional(alias($.__find_of_phrase, $.of_phrase)),
__find_of_phrase: ($) => seq(kw("OF"), field("record", $.__find_record_name)),
```

7. Do not alias `field`'ed compound modifiers unless the fields are inside a `repeat`
```js
// Bad
alias(
   seq(kw("COLUMN-LABEL"), field("column_label", $.string_literal)),
   $.column_label,
),

// Good
seq(kw("COLUMN-LABEL"), field("column_label", $.string_literal)),
alias(
   seq(kw("COLUMN-LABEL"), repeat1(field("column_label", $.string_literal))),
   $.column_label,
),
```

8. Use phrase-scoping alias when optional valued subparts belong to one semantic option

```js
// Bad
seq(
  alias(kw("PERSISTENT"), $.persistent),
  optional(seq(kw("SET"), field("handle", $.identifier))),
),

// Good
alias(
  seq(
    kw("PERSISTENT"),
    optional(seq(kw("SET"), field("handle", $.identifier))),
  ),
  $.persistent,
)
```

Reason: without phrase-level alias, `handle` may bind to a broader parent node
instead of the `persistent` option.

## Notes

- `bun` instead of `npm`.
- Never use `tree-sitter` CLI directly, use workflow commands.
- There is no need to call `bun run build` during testing workflow, just use usual workflow commands like `bun run test` and `bun run parse:snippet`, they build/generate under the hood.
- `bun run test` returns only failed cases and failed syntax tree OR a message that everything went well.
- When using `alias`, `tree-sitter` handles undefined rules by using the property name as the symbol name so it's okay to alias to `$.something_that_wasn't defined`.
- `terminator`, `terminator_dot` or rules prefixed with `_` (unless aliased) should never be visible in the syntax tree output.
- Always prefer `| head` when calling `bun run test` instead of `| tail`.
- The `Permission denied (os error 13)` error occurs because the sandbox blocks writing outside the workspace, preventing tree-sitter from creating its lock file in the user's cache directory.
